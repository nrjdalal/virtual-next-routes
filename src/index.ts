import { virtualNextRoutes as core, virtualNextRoutesSync } from "@/lib/core"
import type { Plugin, ResolvedConfig } from "vite"

export default function virtualNextRoutes({
  cwd = process.cwd(),
  output = "routes.ts",
  debug = false,
}: {
  cwd?: string
  output?: string
  debug?: boolean
} = {}): Plugin {
  // 1️⃣ Generate routes synchronously so the file exists before other plugins run
  virtualNextRoutesSync({ cwd, output, debug })

  let started = false
  let watch = false

  return {
    name: "virtual-next-routes",
    enforce: "pre",

    // 2️⃣ capture whether we're in 'serve' (dev) or 'build' mode
    configResolved(config: ResolvedConfig) {
      watch = config.command === "serve"
    },

    // 3️⃣ start watcher if needed
    // The initial file is already generated by sync call above.
    // We only need to start the watcher logic here.
    // core() will re-generate initially (async) which is fine (idempotent),
    // and then set up watcher.
    async configureServer(_server) {
      if (started) return
      started = true

      // We reuse the async core function for the watcher logic
      await core({
        cwd,
        output,
        watch: true, // we know it's serve if configureServer is called
        debug,
      })
    },

    // For build mode, we don't strictly need to do anything since sync gen happened.
    // But if we want to support async-only transformations in core later, we might keep buildStart.
    // For now, sync is enough for build.
    async buildStart() {
      if (watch) return // handled by configureServer
      if (started) return
      started = true

      // Re-run async generation to be safe / consistent or if sync skipped something?
      // Actually sync covers it. But let's run it to match previous behavior if needed.
      // Or just skip if not watch.
      await core({
        cwd,
        output,
        watch: false,
        debug,
      })
    },
  }
}
