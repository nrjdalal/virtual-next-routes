#!/usr/bin/env node
import { promises as fs, writeFileSync } from "node:fs"
import path from "node:path"
import { parseArgs } from "node:util"
import { author, name, version } from "~/package.json"
import chokidar from "chokidar"

const helpMessage = `Version:
  ${name}@${version}

Usage:
  $ ${name} <command> [options]

Options:
  -v, --version  Display version
  -h, --help     Display help for <command>

Author:
  ${author.name} <${author.email}> (${author.url})`

const parse: typeof parseArgs = (config) => {
  try {
    return parseArgs(config)
  } catch (err: any) {
    throw new Error(`Error parsing arguments: ${err.message}`)
  }
}

function toRoute(relative: string): string {
  const parts = relative.split("/")
  if (parts[parts.length - 1] === "page.tsx") {
    parts.pop()
  }
  const routeParts = parts
    .map((seg) => {
      const match = seg.match(/^\[(.+)\]$/)
      if (match) return `$${match[1]}`
      return seg
    })
    .filter(Boolean)
  return routeParts.length === 0 ? "/" : "/" + routeParts.join("/")
}

const main = async () => {
  try {
    const { positionals, values } = parse({
      allowPositionals: true,
      options: {
        help: { type: "boolean", short: "h" },
        version: { type: "boolean", short: "v" },
      },
    })
    if (!positionals.length) {
      if (values.version) {
        console.log(`${name}@${version}`)
        process.exit(0)
      }
      if (values.help) {
        console.log(helpMessage)
        process.exit(0)
      }
    }

    let rootDirName = "src/routes"
    const configPath = path.join(process.cwd(), "vite.config.ts")
    try {
      const viteConfig = await import(configPath)
      const plugins = viteConfig.default?.plugins || []
      for (const plugin of plugins) {
        if (plugin?.tsr && plugin.tsr.routesDirectory) {
          rootDirName = plugin.tsr.routesDirectory
          break
        }
      }
    } catch {}

    const appDir = path.join(process.cwd(), rootDirName)
    let layoutExists = false
    const pages = new Set<string>()

    async function updateRoutes() {
      let output: string
      if (!layoutExists) {
        output = "export const routes = null"
      } else if (pages.size === 0) {
        output = "export const routes = rootRoute('layout.tsx')"
      } else {
        const entries = Array.from(pages)
          .map((rel) => `route('${toRoute(rel)}', '${rel})')`)
          .join(", ")
        output = `export const routes = rootRoute('layout.tsx', [${entries}])`
      }
      const outPath = path.join(process.cwd(), "routes.ts")
      await fs.writeFile(
        outPath,
        `// This file is auto-generated by ${name} v${version}. Do not edit directly.
        
import {
  index,
  layout,
  physical,
  rootRoute,
  route,
} from "@tanstack/virtual-file-routes"
` +
          "\n" +
          output +
          "\n",
      )
    }

    // Debounce updates: batch rapid changes into a single update
    let updateTimeout: NodeJS.Timeout | null = null
    function scheduleUpdate() {
      if (updateTimeout) clearTimeout(updateTimeout)
      updateTimeout = setTimeout(() => {
        updateRoutes()
        updateTimeout = null
      }, 100)
    }

    // Watch the configured directory and batch any changes
    const watcher = chokidar.watch(appDir, {
      ignoreInitial: false,
      persistent: true,
    })

    watcher.on("all", (event, filePath) => {
      const rel = path.relative(appDir, filePath).split(path.sep).join("/")
      if (rel === "layout.tsx") {
        layoutExists = event === "add" || event === "addDir"
        if (event === "unlink") layoutExists = false
      } else if (rel.endsWith("page.tsx")) {
        if (event === "add") pages.add(rel)
        if (event === "unlink") pages.delete(rel)
      }
      scheduleUpdate()
    })

    console.log(`Watching routes in ${rootDirName}...`)
  } catch (err: any) {
    console.error(helpMessage)
    console.error(`\n${err.message}\n`)
    process.exit(1)
  }
}

main()
